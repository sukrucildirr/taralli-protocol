/*package main

import (
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/math/bits"
)

type Circuit struct {
	X frontend.Variable `gnark:",public"`
	Y frontend.Variable `gnark:",public"`
	E frontend.Variable
}

// Add Fill method to implement witness.Witness interface
func (circuit *Circuit) Fill(values map[string]interface{}) error {
	var ok bool
	if circuit.X, ok = values["X"].(frontend.Variable); !ok {
		return nil
	}
	if circuit.Y, ok = values["Y"].(frontend.Variable); !ok {
		return nil
	}
	if circuit.E, ok = values["E"].(frontend.Variable); !ok {
		return nil
	}
	return nil
}

func (circuit *Circuit) Define(api frontend.API) error {
	const bitSize = 8
	output := frontend.Variable(1)
	bits := bits.ToBinary(api, circuit.E, bits.WithNbDigits(bitSize))
	for i := 0; i < len(bits); i++ {
		if i != 0 {
			output = api.Mul(output, output)
		}
		multiply := api.Mul(output, circuit.X)
		output = api.Select(bits[len(bits)-1-i], multiply, output)
	}
	api.AssertIsEqual(circuit.Y, output)
	return nil
}*/

/*func main() {
	// Step 1: Define and Compile the Circuit
	var circuit Circuit
	cs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)
	if err != nil {
		log.Fatalf("failed to compile circuit: %v", err)
	}

	// Export R1CS to file
	file, err := os.Create("gnark_circuit.r1cs")
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}
	defer file.Close()

	// Use WriteTo to serialize the constraint system
	_, err = cs.WriteTo(file)
	if err != nil {
		log.Fatalf("failed to write R1CS to file: %v", err)
	}

	// Step 2: One-time Setup
	pk, vk, err := groth16.Setup(cs)
	if err != nil {
		log.Fatalf("failed to setup proving/verifying keys: %v", err)
	}

	// Step 3: Create a Witness
	witness, err := frontend.NewWitness(&Circuit{
		X: 2,
		Y: 16,
		E: 4,
	}, ecc.BN254.ScalarField())
	if err != nil {
		log.Fatalf("failed to create witness: %v", err)
	}

	// Step 4: Proof Creation
	proof, err := groth16.Prove(cs, pk, witness)
	if err != nil {
		log.Fatalf("failed to create proof: %v", err)
	}

	// Step 5: Public Witness for Verification
	publicWitness, err := witness.Public()
	if err != nil {
		log.Fatalf("failed to create public witness: %v", err)
	}

	// Step 6: Proof Verification
	err = groth16.Verify(proof, vk, publicWitness)
	if err != nil {
		log.Fatalf("proof verification failed: %v", err)
	}

	log.Println("Proof successfully verified!")

	// Export Solidity verifier contract
	solidityFile, err := os.Create("GnarkVerifier.sol")
	if err != nil {
		log.Fatalf("failed to create Solidity file: %v", err)
	}
	defer solidityFile.Close()

	err = vk.ExportSolidity(solidityFile)
	if err != nil {
		log.Fatalf("failed to export Solidity verifier: %v", err)
	}

	log.Println("Solidity verifier contract exported successfully!")
}*/
